name: Check SDK Sync

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened, ready_for_review]

jobs:
  check-sync:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
      statuses: write
      checks: write
      issues: write

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3
        with:
          path: 'src'
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Compare SDK source and UPM copy
        id: check
        continue-on-error: true
        run: |
          echo "Checking if src/UnityDevProject/Assets/TPromise and src/upm/com.metaversemagna.tpromise are in sync..."
          
          cd src
          
          # Write initial sync status
          echo "checking" > ../sync_status.txt
          
          python3 <<EOF
          import os
          import sys
          import filecmp

          def debug_print(*args):
              print(*args, file=sys.stderr)

          def walk_files(base):
              if not os.path.exists(base):
                  debug_print(f"Directory does not exist: {base}")
                  return []
              files = []
              for root, _, filenames in os.walk(base):
                  for f in filenames:
                      if f.endswith('.meta'):
                          continue
                      full_path = os.path.join(root, f)
                      rel_path = os.path.relpath(full_path, base)
                      files.append(rel_path)
              return sorted(files)

          def files_equal(f1, f2):
              try:
                  # First check file size as quick check
                  if os.path.getsize(f1) != os.path.getsize(f2):
                      debug_print(f"Size mismatch: {f1} vs {f2}")
                      return False
                  
                  # Compare binary content
                  with open(f1, 'rb') as file1, open(f2, 'rb') as file2:
                      content1 = file1.read()
                      content2 = file2.read()
                      if content1 != content2:
                          debug_print(f"Content mismatch between:")
                          debug_print(f"  {f1} (size: {len(content1)})")
                          debug_print(f"  {f2} (size: {len(content2)})")
                          
                          # Find first differing byte
                          for i, (b1, b2) in enumerate(zip(content1, content2)):
                              if b1 != b2:
                                  debug_print(f"First difference at byte {i}: {hex(b1)} vs {hex(b2)}")
                                  break
                          return False
                  return True
              except Exception as e:
                  debug_print(f"Error comparing {f1} and {f2}: {str(e)}")
                  return False

          src = 'UnityDevProject/Assets/TPromise'
          dst = 'upm/com.metaversemagna.tpromise'
          out_of_sync = False

          debug_print("\n=== Starting Sync Check ===")
          debug_print(f"Source: {src}")
          debug_print(f"Destination: {dst}")

          # Check if directories exist
          if not os.path.exists(src):
              debug_print(f"Error: Source directory {src} does not exist")
              sys.exit(1)

          if not os.path.exists(dst):
              debug_print(f"Error: Destination directory {dst} does not exist")
              sys.exit(1)

          src_files = walk_files(src)
          dst_files = walk_files(dst)

          debug_print(f"\nSource files ({len(src_files)}):")
          debug_print("\n".join(src_files[:10]) + ("\n..." if len(src_files) > 10 else ""))
          
          debug_print(f"\nDestination files ({len(dst_files)}):")
          debug_print("\n".join(dst_files[:10]) + ("\n..." if len(dst_files) > 10 else ""))

          # Check for missing files
          if len(src_files) != len(dst_files):
              debug_print(f"\nFile count mismatch: Source has {len(src_files)} files, Destination has {len(dst_files)} files")
              out_of_sync = True
          else:
              debug_print("\nFile counts match")

          # Compare files
          if not out_of_sync:
              for rel_path in src_files:
                  full_src = os.path.join(src, rel_path)
                  full_dst = os.path.join(dst, rel_path)
                  
                  if not os.path.exists(full_dst):
                      debug_print(f"\nMissing in destination: {rel_path}")
                      out_of_sync = True
                      break
                      
                  if not files_equal(full_src, full_dst):
                      debug_print(f"\nContent mismatch: {rel_path}")
                      out_of_sync = True
                      break

          debug_print("\n=== Final Result ===")
          debug_print("Out of sync:" if out_of_sync else "In sync")
          
          # Write result
          with open('../sync_status.txt', 'w') as f:
              f.write('out_of_sync' if out_of_sync else 'in_sync')
          EOF

          # Capture the Python exit code
          python_exit_code=$?
          if [ $python_exit_code -ne 0 ]; then
            echo "out_of_sync" > ../sync_status.txt
          fi
          
          # Print debug output
          echo "Python script output:"
          cat src/../sync_status.txt
          exit 0
      
      - name: Set status output
        id: result
        run: |
          echo "sync_status=$(cat src/sync_status.txt)" >> $GITHUB_OUTPUT
          echo "status=$(cat src/sync_status.txt)" >> $GITHUB_ENV

      - name: Create Required Status Check
        uses: actions/github-script@v7
        with:
          script: |
            const status = process.env.status;
            const conclusion = status === 'in_sync' ? 'success' : 'failure';
            
            // Create required status check
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.payload.pull_request.head.sha,
              state: conclusion,
              context: 'UPM Sync Status',
              description: status === 'in_sync' 
                ? 'UPM package is synced' 
                : 'UPM package is out of sync',
            });

            // Additional check for visibility
            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'UPM Package Sync',
              head_sha: context.payload.pull_request.head.sha,
              status: 'completed',
              conclusion: conclusion,
              output: {
                title: status === 'in_sync' ? 'Sync OK' : 'Sync Required',
                summary: status === 'in_sync'
                  ? 'All files are synchronized'
                  : 'Run Sync to UPM in Unity and commit changes',
              }
            });

      - name: Update PR title with sync badge
        uses: actions/github-script@v7
        with:
          script: |
            const status = process.env.status;
            const title = context.payload.pull_request.title;
            
            // Remove ALL existing sync tags (both old and new formats)
            const cleanedTitle = title
              .replace(/^\[UPM (SYNC|OUT-OF-SYNC)[^\]]*\][\s-]*/g, '')
              .replace(/^\[SYNC[^\]]*\][\s-]*/g, '')
              .trim();
            
            const newPrefix = status === 'in_sync' 
              ? '[UPM SYNC ✅]' 
              : '[UPM OUT-OF-SYNC ❌]';
            
            const finalTitle = `${newPrefix} ${cleanedTitle}`;

            if (finalTitle !== title) {
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                title: finalTitle
              });
            }

      - name: Post sync warning
        if: env.status == 'out_of_sync'
        uses: actions/github-script@v7
        with:
          script: |
            const commentBody = `🚨 **UPM Sync Required**\n\n` +
              `The UPM package is out of sync with source files.\n\n` +
              `**Required Action:**\n` +
              `1. Open Unity project\n` +
              `2. Go to **TPromise > Sync to UPM**\n` +
              `3. Commit and push all changes\n\n` +
              `🔒 *This PR cannot be merged until sync is complete*`;
              
            // Delete any existing sync comments first
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            const syncComments = comments.data.filter(c =>
              c.body && c.body.includes('**UPM Sync Required**')
            );
            
            for (const comment of syncComments) {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: comment.id
              });
            }
            
            // Post new comment
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });
